package main

import (
	"fmt"
	"sync"
)

func main() {
	num := []int{2, 4, 6, 8, 10}

	// Mutex
	fmt.Println("Результат через mutex: ", SqrWithMutex(num))
	// Chan
	fmt.Println("Результат через chan: ", SqrWithChan(num))
}

func SqrWithMutex(in []int) []int {
	sliceCopy := append(in[:0:0], in...) // Создаём слайс, который являеться копией входного слайса поскольку без копии мы бы вносили изменения в изначальный слайс num из main ибо в слайсах используються ссылки

	// Инициализируем структуру mutex для использования методов безопасности доступа к данным горутинами
	//mu := sync.RWMutex{}
	// Объявляем WaitGroup для синхронизации горутин
	var wg sync.WaitGroup

	for i, v := range sliceCopy {
		wg.Add(1) // Инкриментим счётчик для отслеживания колличества запущеных горутин
		go func(index, v int) {
			defer wg.Done() // Декриментим счётчик когда горутина окончит работу
			sqr := v * v
			//mu.Lock() // Захватываем mutex в режим записи, чтобы гарантировать безопасность записи(в нашем случае)
			sliceCopy[index] = sqr
			//mu.Unlock() // Отпускаем mutex, чтобы другие горутины могли произвести запись
		}(i, v)
	}
	wg.Wait() // Ожидаем выполнение всех горутин - пока wg.Add не приобритет значение 0
	return sliceCopy
}

func SqrWithChan(in []int) []int {
	sliceCopy := append(in[:0:0], in...) // Создаём слайс, который являеться копией входного слайса поскольку без копии мы бы вносили изменения в изначальный слайс num из main ибо в слайсах используються ссылки
	ch := make(chan func())              // Создаем канал который будет использоваться для передачи функций,
	// Объявляем WaitGroup для синхронизации горутин
	var wg sync.WaitGroup
	go func() { // Запускаем горутину, которая бесконечно читает функции из канала ch и выполняет их до мемента пока wg.Wait не завершит её
		for {
			f := <-ch
			f()
		}
	}()
	for i, el := range sliceCopy {
		wg.Add(1) // Инкриментим счётчик для отслеживания колличества запущеных горутин
		go func(index, n int) {
			f := func() {
				defer wg.Done() // Декриментим счётчик когда горутина окончит работу
				sqr := n * n
				sliceCopy[index] = sqr
			}
			ch <- f // передаём функцию в канал
		}(i, el) // Запускаем горутину через замыкание
	}

	wg.Wait() // Ожидаем выполнение всех горутин - пока wg.Add не приобритет значение 0
	return sliceCopy
}

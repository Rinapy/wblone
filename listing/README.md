## 1.Какой самый эффективный способ конкатенации строк?
В Go есть несколько способов конкатенации строк, и эффективность каждого из них может зависеть от контекста использования.

### Первый из них конкатенация через оператор +

Оператор + сливает строки вместе, но внутри себя он создает новую строку, копируя содержимое обоих строк. Если вам нужно объединить большое количество строк, использование оператора + может быть неэффективным.
```go
package main

import "fmt"
        
func main() {
    str1 := "Hello"
    str2 := "World"
    result := str1 + " " + str2
    fmt.Println(result)
}
```

### Второй вариант использование пакета bytes

Пакет bytes предоставляет тип Buffer, который можно использовать для эффективной конкатенации строк.

При использовании типа Buffer строки объединяются в буфере без необходимости создавать новые строки каждый раз. Это может быть эффективнее, особенно для конкатенации большого количества строк.

```go
package main

import (
	"fmt"
	"bytes"
)
        
func main() {
    str1 := "Hello"
    str2 := "World"
	var buffer bytes.Buffer
	buffer.Reset() //мы можем повторно использовать часть памяти, используя Rest
	buffer.WriteString(str1)
	buffer.WriteString(" ")
	buffer.WriteString(str2)

	result := buffer.String()

	fmt.Println(result)
}
```

### Третий вариант использование пакета strings.

Пакет strings предоставляет функцию Join, которая позволяет объединить срез строк в одну строку. Функция Join принимает срез строк и разделитель и объединяет их в одну строку
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    str := []string{"Hello", "World"}
    result := strings.Join(str, " ")

    fmt.Println(result)
}
```

[Тесты](https://gist.github.com/dtjm/c6ebc86abe7515c988ec)

Которые показывают - что лучше всех c конкатенацией справляется bytes.Buffer с ```buffer.Reset().```

## 2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы в языке программирования Go представляют собой абстрактные типы данных, которые определяют набор методов. Они позволяют определить контракт между различными типами данных, указывая, какие методы должны быть реализованы у конкретного типа, чтобы удовлетворять этому интерфейсу.

В Go интерфейсы применяются для достижения гибкости и повторного использования кода. Они позволяют создавать абстракции, которые не зависят от конкретных типов, что упрощает написание обобщенного кода.

Для реализации интерфейса не требуется явно указывать, что определенный тип "реализует" интерфейс. Вместо этого необходимо, чтобы у типа были методы с сигнатурами, соответствующими методам интерфейса.

## 3. Чем отличаются RWMutex от Mutex?

RWMutex и Mutex - это два типа в Go, используемые для управления доступом к общим данным из нескольких горутин. Они отличаются по способу управления блокировками и предоставления доступа к данным.

Mutex обеспечивает эксклюзивную блокировку, позволяя только одной горутине одновременно получить доступ к общим данным. Это означает, что если горутина происходит запись или чтение, другие горутины должны ждать, пока блокировка не будет освобождена.

RWMutex, с другой стороны, предоставляет два уровня блокировки: защиту для чтения (RLock) и защиту для записи (Lock). RLock позволяет нескольким горутинам читать данные одновременно, пока нет блокировки для записи, тогда как Lock обеспечивает эксклюзивный доступ для записи.

Использование RWMutex может повысить параллелизм в программе, поскольку разрешает множественные чтения, но только одну запись за раз. Однако, это также требует более тщательного управления блокировками, чтобы избежать гонок данных.

## 4. Чем отличаются буферизированные и не буферизированные каналы?

Буферизированные и не буферизированные каналы в языке программирования Go отличаются по способу хранения и передачи данных между горутинами.

Не буферизированные каналы предоставляют синхронную передачу данных между горутинами. Это означает, что отправка данных в канал блокирует горутину до тех пор, пока данные не будут получены другой горутиной из канала. Это обеспечивает точную передачу данных, когда отправитель и получатель должны синхронизироваться.

С другой стороны, буферизированные каналы позволяют отправлять данные в канал, даже если нет готового получателя. Канал хранит переданные данные в буфере до момента, когда они будут извлечены другой горутиной. В случае буферизированных каналов неблокирующая отправка данных позволяет отправляющей горутине продолжить работу без ожидания готовности получателя.

Выбор между буферизированными и не буферизированными каналами зависит от конкретных требований приложения. Не буферизированные каналы подходят для случаев, когда отправитель и получатель должны синхронизироваться по передаче данных. Буферизированные каналы могут использоваться в тех случаях, когда скорость отправки и получения данных различна или когда требуется временный буфер для данных.

## 5. Какой размер у структуры struct{}{}?

0 байт. этот лайфхак в го используют как пустую заглушку в каналах и хэш-мапах.

## 6. Есть ли в Go перегрузка методов или операторов?

Перегрузки операторов в Go нет. перегрузка методов до версии 1.18 была возможна через интерфейсные аргументы функции. но теперь для этого есть дженерики.

## 7. В какой последовательности будут выведены элементы ?
```go 
map[int]int{0:1,1:124,2:281}
```
В Go нет гарантированного порядка, в котором элементы будут извлечены из map. При обходе map элементы могут быть извлечены в произвольном порядке, так как map использует хэширование для хранения данных. Это означает, что порядок элементов зависит от хеш-функции и распределения ключей в map, что может меняться в зависимости от размера map и других факторов.

## 8. В чем разница make и new ?
make используется для выделения и инициализации слайсов, карт (maps) и каналов, которые являются частью специфической группы типов в Go, называемой ссылочными типами, поскольку их размер или данные могут изменяться во время выполнения. make не только выделяет память, но и инициализирует значение, так что оно не нулевое и готово к использованию.

new(T) используется для выделения памяти для нового элемента типа T. T может быть любым типом, включая встроенные типы, сложные пользовательские типы, структуры и так далее. Возвращаемое значение new — это указатель на нулевой (zero-value) экземпляр типа T. Нулевое значение — это значение, которое переменная данного типа имеет по умолчанию при объявлении без инициализации. Например, для чисел это будет 0, для указателей — nil, для boolean — false, а для структур — структура с нулевыми значениями в каждом поле.

## 9. Сколько существует способов задать переменную типа slice или map?
### Для Slice'ov:

#### 1. Используя make для создания слайса с начальным размером и (необязательно) ёмкостью:
```go
s := make([]int, 10) // Слайс из 10 нулей
s := make([]int, 0, 10) // Пустой слайс с ёмкостью 10
```
#### 2. С помощью литерала слайса для задания начальных значений:
```go
s := []int{1, 2, 3}
```

#### 3. Объявляя переменную слайса, которая по умолчанию будет инициализирована в nil:
```go
var s []int // s == nil
```

#### 4. Создание слайса путём вырезания его из существующего массива:
```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:3] // [2, 3]
```

#### 5. Используя функцию new, которая возвращает указатель на слайс. Это не самый распространенный способ, и он чаще всего используется, когда нужен указатель на слайс.
```go

s := new([]int) // *s == nil
```

### Для Map:

#### 1. Используя make для создания карты:
```go
m := make(map[string]int) // Пустая мапа
```

#### 2. С помощью литерала мапы для задания начальных ключей и значений:
```go
m := map[string]int{"one": 1, "two": 2}
```

#### 3. Объявляя переменную мапы, которая будет инициализирована в nil:
```go
var m map[string]int // m == nil
```
Хотя функция new технически может быть использована для создания мапы, это довольно редкая практика, так как она приведёт к созданию указателя на нулевую мапу, и перед её использованием требуется инициализация:

```go
m := new(map[string]int) // *m == nil
*m = make(map[string]int)
```
Инициализированную через new без последующего вызова make, это приведёт к ошибке времени выполнения, поскольку нулевые слайс или мапа не могут непосредственно использоваться для доступа к элементам или добавления новых элементов.

### 10. Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
этот код выведет 1 1, что связано с темами variable shadowing и copy by value, в функцию update попадает лишь копия указателя p, которая исчезнет при завершении update(). чтобы код в update() повлиял на main(), вместо p = &b нужно *p = b.


### 11. Что выведет данная программа и почему?

```go
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}

```

fatal error: all goroutines are asleep - deadlock!  
Варианты решения:   
sync.WaitGroup должен передаваться по указателю, чтобы внесенные изменения в него были видны за пределами горутины.\
Через closure

### 12. Что выведет данная программа и почему?

```go
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}
```
Выведет 0   
При выполнении условия if true внутри функции main создается новая переменная n с помощью оператора := и инициализируется значением 1. Затем значение этой переменной увеличивается на 1. Однако, эта переменная n существует только внутри блока if, и за его пределами используется глобальная переменная n, которая была инициализирована сначала значением 0.

### 13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}

func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}
```
Выведет [100 2 3 4 5]   
var a = []int8{1, 2, 3, 4, 5} - Это инициализированный слайс и в переменной храниться ссылка на память  
v[0] = 100 изменит значение в память    
при добавлении элемента b в конец массива v с помощью функции append, это изменение происходит только в локальной копии массива v внутри функции someAction

### 14. Что выведет данная программа и почему?

```go
func main() {
slice := []string{"a", "a"}

func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}

```
Вывод [b b a][a a] по тем же причинам, что и в 13 вопросе

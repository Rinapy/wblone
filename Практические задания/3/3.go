package main

import (
	"fmt"
	"sync"
)

func main() {
	//origNum := []int{2, 4, 6, 8, 10}
	num := make([]int, 0) // Для болшей наглядности RWMutex решил увеличить размер слайса
	for i := 0; i != 1000000; i += 2 {
		num = append(num, i)
	}
	// Mutex
	fmt.Println("Результат через mutex: ", CubeSumWithMutex(num))
	// Chan
	fmt.Println("Результат через chan: ", CubeSumWithChan(num))
}

func CubeSumWithMutex(in []int) int {
	sliceCopy := append(in[:0:0], in...) // Создаём слайс, который являеться копией входного слайса поскольку без копии мы бы вносили изменения в изначальный слайс num из main ибо в слайсах используються ссылки
	var CubeSum int
	// Инициализируем структуру mutex для использования методов безопасности доступа к данным горутинами
	mu := sync.RWMutex{}
	// Объявляем WaitGroup для синхронизации горутин
	var wg sync.WaitGroup

	for i, v := range sliceCopy {
		wg.Add(1) // Инкриментим счётчик для отслеживания колличества запущеных горутин
		go func(index, v int) {
			defer wg.Done() // Декриментим счётчик когда горутина окончит работу
			cube := v * v * v
			mu.Lock() // Захватываем mutex в режим записи, чтобы гарантировать безопасность обновления(в нашем случае) в случае небольшого объёма чисел ошибки без лока маловероятны, но на больших значениях будут явны
			CubeSum += cube
			mu.Unlock() // Отпускаем mutex, чтобы другие горутины могли обновить данные
		}(i, v)
	}
	wg.Wait() // Ожидаем выполнение всех горутин - пока wg.Add не приобритет значение 0
	return CubeSum
}

func CubeSumWithChan(in []int) int {
	sliceCopy := append(in[:0:0], in...) // Создаём слайс, который являеться копией входного слайса поскольку без копии мы бы вносили изменения в изначальный слайс num из main ибо в слайсах используються ссылки
	var CubeSum int
	ch := make(chan func()) // Создаем канал который будет использоваться для передачи функций
	// Объявляем WaitGroup для синхронизации горутин
	var wg sync.WaitGroup
	go func() { // Запускаем горутину, которая бесконечно читает функции из канала ch и выполняет их до мемента пока wg.Wait не завершит её
		for {
			f := <-ch
			f()
		}
	}()
	for i, el := range sliceCopy {
		wg.Add(1) // Инкриментим счётчик для отслеживания колличества запущеных горутин
		go func(index, n int) {
			f := func() {
				defer wg.Done() // Декриментим счётчик когда горутина окончит работу
				cube := n * n * n
				CubeSum += cube
			}
			ch <- f // передаём функцию в канал
		}(i, el) // Запускаем горутину через замыкание
	}

	wg.Wait() // Ожидаем выполнение всех горутин - пока wg.Add не приобритет значение 0
	return CubeSum
}
